{% extends 'navbar.html' %}

{% load static %}


{% block content %}


    <style>
        body{
            background-color: black;
            background-image: url("/static/assets/bg.png");
            background-repeat: no-repeat;
            background-size: cover;
        }
        .results {
            margin-top: 20px;
            padding: 10px;
            background-color: #000000;
            width: 100%;
            text-align: center;
            color:white;
        }
        #snapButton{
            
            margin-top:20px;
        }
        #toggleCameraButton{
            
            margin-top:20px;
        }
        
video {
  transform: scaleX(-1);
  margin-top: 5px;
}

/* Flipping the canvas image as it was not mirror view */
#canvas {
  transform: scaleX(-1);
  filter: FlipH;
}
    </style>

<body>
    <div class="jumbotron" style="margin-top:20px;padding:20px;">
        <p><span id="errorMsg"></span></p>
        <div class="row">
          <div class="col-lg-6">
            <!-- Here we stream video from the webcam -->
            <h4>
              <FONT COLOR = white> Video coming from Webcam
              <button class="btn btn-primary" id="btnCapture">Capture to Canvas >></button>
              <button class="btn btn-primary" id="toggleCamera">Toggle Camera</button>

            </h4>
            <video id="video" playsinline autoplay alt="Webcam video stream"></video>
          </div>
      
          <div class="col-lg-6">
            <h4>
            <FONT COLOR = white> Captured image from Webcam
              <button type="submit" class="btn btn-primary" id="btnSave" name="btnSave">Save the canvas (image) to server</button>
            </h4>
            <!-- Webcam video snapshot -->
            <canvas id="canvas" width="475" height="475" alt="Canvas image"></canvas>
          </div>
        </div>
      </div>



    <script>
        

        const video = document.querySelector("#video");

// Basic settings for the video to get from Webcam
const constraints = {
  audio: false,
  video: {
    width: 475,
    height: 475
  }
};

// This condition will ask permission to user for Webcam access
if (navigator.mediaDevices.getUserMedia) {
  navigator.mediaDevices.getUserMedia(constraints)
    .then(function(stream) {
      video.srcObject = stream;
    })
    .catch(function(err0r) {
      console.log("Something went wrong!");
    });
}

function stop(e) {
  const stream = video.srcObject;
  const tracks = stream.getTracks();

  for (let i = 0; i < tracks.length; i++) {
    const track = tracks[i];
    track.stop();
  }
  video.srcObject = null;
}


// Below code to capture image from Video tag (Webcam streaming)
const btnCapture = document.querySelector("#btnCapture");
const canvas = document.getElementById('canvas');

btnCapture.addEventListener('click', function() {
  const context = canvas.getContext('2d');
  // Capture the image into canvas from Webcam streaming Video element
  context.drawImage(video, 0, 0);
  
});

// Upload image to server - ajax call - with the help of base64 data as a parameter
const btnSave = document.querySelector("#btnSave");

btnSave.addEventListener('click', async function() {
  // Below new canvas to generate flip/mirror image from existing canvas
  const destinationCanvas = document.createElement("canvas");
  const destCtx = destinationCanvas.getContext('2d');

  destinationCanvas.height = 500;
  destinationCanvas.width = 500;

  destCtx.translate(video.videoWidth, 0);
  destCtx.scale(-1, 1);
  destCtx.drawImage(document.getElementById("canvas"), 0, 0);

  // Get base64 data to send to server for upload
  let imagebase64data = destinationCanvas.toDataURL("image/png");
  imagebase64data = imagebase64data.replace('data:image/png;base64,', '');

  try {
    const response = await fetch("predict/", {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json; charset=utf-8'
      },
      body: JSON.stringify({
        imageData: imagebase64data
      })
    });

    if (response.ok) {
      alert('Image uploaded successfully..');
    } else {
      throw new Error(`Request failed with status ${response.status}`);
    }
  } catch (error) {
    console.error('Error while uploading image:', error);
  }
});



    if (navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia(constraints)
        .then(function(stream) {
          video.srcObject = stream;
        })
        .catch(function(err) {
          console.log("Something went wrong!");
        });
    }

    function toggleCamera() {
      if (video.srcObject) {
        const stream = video.srcObject;
        const tracks = stream.getTracks();
        tracks.forEach(function(track) {
          track.stop();
        });
        video.srcObject = null;
      } else {
        navigator.mediaDevices.getUserMedia(constraints)
          .then(function(stream) {
            video.srcObject = stream;
          })
          .catch(function(err) {
            console.log("Something went wrong!");
          });
      }
    }

    document.getElementById('toggleCamera').addEventListener('click', toggleCamera);

    // video-capture.js

// Event listener for "Take Photo" button
document.getElementById('btnSave').addEventListener('click', async function() {
    try {
        const blob = await capturePhoto(); // Assuming capturePhoto() returns a Blob
        await sendToServer(blob); // Send the captured photo to the backend
        console.log('Photo sent successfully!');
    } catch (error) {
        console.error('Error sending photo:', error);
    }
});

async function capturePhoto() {
    const video = document.getElementById('video');
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const context = canvas.getContext('2d');
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    const imageUrl = canvas.toDataURL('image/png');
    const blob = await fetch(imageUrl).then((res) => res.blob()); // Convert data URL to Blob
    return blob;
}

async function sendToServer(blob) {
    const formData = new FormData();
    formData.append('photo', blob, 'captured-photo.jpg'); // Adjust the field name and filename
    
    try {
        const response = await fetch('predict/', {
            method: 'POST',
            body: formData, // Use FormData directly without setting Content-Type
            headers: {
                'Accept': 'application/json',
                "Content-Type": "multipart/form-data",
                 "x-csrf-token": _csrf
            }
        });

        if (response.ok) {
            console.log('Photo sent to server successfully!');
        } else {
            console.error('Error sending photo to server:', response.statusText);
        }
    } catch (error) {
        console.error('Network error:', error);
    }
}



   </script>
   
</body>
</html>





{% endblock %}


{% block scripts %}
<script type="text/javascript" src="{% static 'js/scripts.js' %}"></script>
{% endblock %}